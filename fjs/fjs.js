// Generated by CoffeeScript 1.6.3
/*
    FJS compiler
    coffee fjs.coffee test
*/


(function() {
  var Context, Frame, callDepth, charByName, compileFunc, debugCompile, debugRuntime, decodeSymbol, depth, encodeSymbol, funcOut, haveDbgInspect, i, localVarIdxStk, localVarStack, longPad, nameByChar, path, resetFuncOut, symByWord, version, withStmntStack, wordBySym, _i,
    __slice = [].slice;

  version = '0.1.0';

  debugCompile = false;

  debugRuntime = false;

  path = "(eval)";

  longPad = '';

  for (i = _i = 0; _i <= 25; i = ++_i) {
    longPad += '     ';
  }

  withStmntStack = [];

  localVarStack = [];

  localVarIdxStk = [];

  callDepth = -1;

  depth = 0;

  haveDbgInspect = false;

  funcOut = "";

  resetFuncOut = function() {
    return funcOut = ("\n// File " + path + " compiled by FJS version " + version + "\n") + "// Hacked by Ramsey Nasser December 2013 for the Emojinal Project\n" + ("// Generated on " + (new Date().toString().slice(0, 21)) + "\n\n");
  };

  resetFuncOut();

  /*
      FJS primitive functions
  */


  window.Primitives = {
    _lbkt__rbkt_: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        return [args];
      } else {
        return [[]];
      }
    },
    _lbrace__rbrace_: function() {
      var args, obj;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        obj = {};
        i = 0;
        while (i < args.length - 1) {
          obj[args[i].toString()] = args[i + 1];
          i += 2;
        }
        return obj;
      } else {
        return {};
      }
    },
    _dot_: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        return console.log.apply(console, args);
      } else {
        console.log(args[0]);
        return args.slice(1);
      }
    },
    dup: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        return args.concat(args);
      } else {
        return args.slice(0, 1).concat(args);
      }
    },
    drop: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        return void 0;
      } else {
        return args.slice(1);
      }
    },
    truthy: function() {
      var arg, args, _j, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        for (i = _j = 0, _len = args.length; _j < _len; i = ++_j) {
          arg = args[i];
          if (!args[i]) {
            return false;
          }
        }
        return true;
      } else {
        return [!!args[0]].concat(args.slice(1));
      }
    },
    not: function() {
      var arg, args, _j, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        for (i = _j = 0, _len = args.length; _j < _len; i = ++_j) {
          arg = args[i];
          args[i] = !args[i];
        }
        return args;
      } else {
        return [!args[0]].concat(args.slice(1));
      }
    },
    over: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        return args.slice(-1).concat(args);
      } else {
        return args.slice(1, 2).concat(args);
      }
    },
    swap: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        return args.slice(1).concat(args.slice(0, 1));
      } else {
        return [args[1], args[0]];
      }
    },
    get: function() {
      var args, obj, res, _j, _len, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      obj = args[0];
      if (this.overrideDefault) {
        res = [];
        _ref = args.slice(1);
        for (_j = 0, _len = _ref.length; _j < _len; _j++) {
          args = _ref[_j];
          res.push(obj[arg]);
        }
        return res;
      } else {
        return obj[args[1]];
      }
    },
    _plus_: function() {
      var arg, args, haveStr, total, _j, _k, _len, _len1;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        haveStr = false;
        for (_j = 0, _len = args.length; _j < _len; _j++) {
          arg = args[_j];
          if (typeof arg === 'string') {
            haveStr = true;
            break;
          }
        }
        total = (haveStr ? '' : 0);
        for (_k = 0, _len1 = args.length; _k < _len1; _k++) {
          arg = args[_k];
          total += arg;
        }
        return total;
      } else {
        if (args.length < 2) {
          return args;
        } else {
          return [args[0] + args[1]].concat(args.slice(2));
        }
      }
    },
    _dash_: function() {
      var arg, args, total, _j, _len, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault && args.length > 2) {
        total = +args[0];
        _ref = args.slice(1);
        for (_j = 0, _len = _ref.length; _j < _len; _j++) {
          arg = _ref[_j];
          total -= arg;
        }
        return total;
      } else {
        if (args.length < 2) {
          return args;
        } else {
          return [args[0] - args[1]].concat(args.slice(2));
        }
      }
    },
    _star_: function() {
      var arg, args, total, _j, _len, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault && args.length > 2) {
        total = +args[0];
        _ref = args.slice(1);
        for (i = _j = 0, _len = _ref.length; _j < _len; i = ++_j) {
          arg = _ref[i];
          total *= arg;
        }
        return total;
      } else {
        if (args.length < 2) {
          return args;
        } else {
          return [args[0] * args[1]].concat(args.slice(2));
        }
      }
    },
    _slash_: function() {
      var arg, args, total, _j, _len, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault && args.length > 2) {
        total = +args[0];
        _ref = args.slice(1);
        for (_j = 0, _len = _ref.length; _j < _len; _j++) {
          arg = _ref[_j];
          total /= arg;
        }
        return total;
      } else {
        if (args.length < 2) {
          return args;
        } else {
          return [args[0] / args[1]].concat(args.slice(2));
        }
      }
    },
    or: function() {
      var arg, args, _j, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        for (i = _j = 0, _len = args.length; _j < _len; i = ++_j) {
          arg = args[i];
          if (args[i]) {
            return true;
          }
        }
        return false;
      } else {
        if (args.length < 2) {
          return args;
        } else {
          return [args[0] || args[1]].concat(args.slice(2));
        }
      }
    },
    and: function() {
      var arg, args, _j, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        for (i = _j = 0, _len = args.length; _j < _len; i = ++_j) {
          arg = args[i];
          if (!args[i]) {
            return false;
          }
        }
        return true;
      } else {
        if (args.length < 2) {
          return args;
        } else {
          return [args[0] && args[1]].concat(args.slice(2));
        }
      }
    },
    _eq_: function() {
      var arg, args, top, _j, _len, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        top = args[0];
        _ref = args.slice(1);
        for (i = _j = 0, _len = _ref.length; _j < _len; i = ++_j) {
          arg = _ref[i];
          if (top !== arg) {
            return false;
          }
        }
        return true;
      } else {
        if (args.length < 2) {
          return true;
        } else {
          return [args[0] === args[1]].concat(args.slice(2));
        }
      }
    },
    _lt_: function() {
      var arg, args, _j, _len, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        _ref = args.slice(1);
        for (i = _j = 0, _len = _ref.length; _j < _len; i = ++_j) {
          arg = _ref[i];
          if (arg[i - 1] >= arg) {
            return false;
          }
        }
        return true;
      } else {
        if (args.length < 2) {
          return false;
        } else {
          return [args[0] < args[1]].concat(args.slice(2));
        }
      }
    },
    _gt_: function() {
      var arg, args, _j, _len, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        _ref = args.slice(1);
        for (i = _j = 0, _len = _ref.length; _j < _len; i = ++_j) {
          arg = _ref[i];
          if (arg[i - 1] <= arg) {
            return false;
          }
        }
        return true;
      } else {
        if (args.length < 2) {
          return false;
        } else {
          return [args[0] > args[1]].concat(args.slice(2));
        }
      }
    },
    _if_: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      console.log('_if_', args);
      if (typeof args[0] === 'function' && args[0].call(this || args[0])) {
        args[1].apply(this, args.slice(2));
      }
      return void 0;
    },
    doif: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (typeof args[1] === 'function' && args[1].call(this || args[1])) {
        args[0].apply(this, args.slice(2));
      }
      return void 0;
    },
    _while_: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      while (args[0].call(this)) {
        args[1].apply(this, args.slice(2));
      }
      return void 0;
    },
    repeat: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      while (true) {
        args[0].apply(this, args.slice(1));
        if (this.pop() === false) {
          break;
        }
      }
      return void 0;
    },
    dowhile: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      while (args[1].call(this)) {
        args[0].apply(this, args.slice(2));
      }
      return void 0;
    },
    map: function() {
      var args, item, res, _j, _len, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      res = [];
      _ref = args[1];
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        item = _ref[_j];
        args[0].call(this, item);
        res.push(this.pop());
      }
      return [res];
    },
    each: function() {
      var args, item, res, resItem, _j, _len, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      res = [];
      _ref = args[1];
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        item = _ref[_j];
        args[0].call(this, item);
        if ((resItem = this.pop()) === false) {
          break;
        }
        res.push(resItem);
      }
      return [res];
    },
    rot: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.overrideDefault) {
        return args.slice(-1).concat(args.slice(0, -1));
      } else {
        return args.slice(2, 3).concat(args.slice(0, 2), args.slice(3));
      }
    },
    set: function() {
      var args, obj;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      obj = args[0];
      if (this.overrideDefault) {
        i = 0;
        while (i < args.length - 1) {
          obj[args[i]] = args[i + 1];
          i += 2;
        }
        return res;
      } else {
        return obj[args[1]] = args[2];
      }
    },
    _new_: function() {
      var arg, args, argsArr, constructor, _j, _len, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      constructor = args[0];
      argsArr = [];
      _ref = args.slice(1);
      for (i = _j = 0, _len = _ref.length; _j < _len; i = ++_j) {
        arg = _ref[i];
        argsArr.push('args[' + i + ']');
      }
      return eval('new constructor(' + argsArr.join(',') + ')');
    }
  };

  Frame = (function() {
    function Frame(codeFuncSegs, segIdx, stack, args) {
      this.codeFuncSegs = codeFuncSegs;
      this.segIdx = segIdx != null ? segIdx : 0;
      this.stack = stack != null ? stack : [];
      this.args = args != null ? args : [];
    }

    Frame.prototype.clone = function() {
      return new Frame(this.codeFuncSegs, this.segIdx, this.stack.slice(0, this.args.slice(0)));
    };

    return Frame;

  })();

  Context = (function() {
    function Context(curFrame) {
      this.curFrame = curFrame != null ? curFrame : null;
      this.frames = [];
      this.callbacksPending = 0;
    }

    Context.prototype.clone = function() {
      var newCtxt;
      return newCtxt = new Context(this.curFrame.clone());
    };

    Context.prototype.stack = function() {
      return this.curFrame.stack;
    };

    Context.prototype.moveArgsToStack = function(n) {
      var frame2;
      if (!(frame2 = this.frames.slice(-1)[0])) {
        return;
      }
      if (!n) {
        this.curFrame.stack = frame2.args.concat(this.curFrame.stack);
        return frame2.args = [];
      } else {
        return this.curFrame.stack = frame2.args.splice(0, n).concat(this.curFrame.stack);
      }
    };

    Context.prototype.setArgs = function(args) {
      return this.curFrame.args = Array.prototype.slice.call(args);
    };

    Context.prototype.pop = function() {
      return this.curFrame.stack.shift();
    };

    Context.prototype.popAll = function() {
      var stk;
      stk = this.curFrame.stack;
      this.curFrame.stack = [];
      return stk;
    };

    Context.prototype.popN = function(n) {
      n || (n = this.curFrame.stack.length);
      return this.curFrame.stack.splice(0, n);
    };

    Context.prototype.push = function(v) {
      return this.curFrame.stack.unshift(v);
    };

    Context.prototype["new"] = function(Class, args) {
      return (function() {
        var construct;
        construct = function() {
          return Class.apply(this, args);
        };
        construct.prototype = Class.prototype;
        return new construct;
      })();
    };

    Context.prototype.pushArray = function(array) {
      return this.curFrame.stack = array.concat(this.curFrame.stack);
    };

    Context.prototype.pushReturnValue = function(val) {
      if (typeof val === 'undefined') {
        return;
      }
      if (val instanceof Array) {
        return this.pushArray(val);
      } else if (toString.call(val) === '[object Arguments]') {
        return this.pushArray(Array.prototype.slice(call(val)));
      } else {
        return this.curFrame.stack.unshift(val);
      }
    };

    Context.prototype.pushArgsAndExec = function(f, n) {
      if (n == null) {
        n = this.curFrame.stack.length;
      }
      this.overrideDefault = true;
      this.pushReturnValue(f.apply(this, this.curFrame.stack.splice(0, n)));
      return delete this.overrideDefault;
    };

    Context.prototype.execOrPush = function(word) {
      var stk;
      if (typeof word === 'function') {
        stk = this.curFrame.stack;
        this.curFrame.stack = [];
        return this.pushReturnValue(word.apply(this, stk));
      } else {
        return this.push(word);
      }
    };

    Context.prototype.pushCB = function(debugFunc) {
      this.curFrame.stack.unshift(this._callback.bind(this, debugFunc));
      return this.callbacksPending++;
    };

    Context.prototype._callback = function() {
      var args, ctxt, debugFunc;
      debugFunc = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (--this.callbacksPending > 0) {
        return;
      }
      ctxt = (this.callbacksPending === 0 ? this : ctxt = this.savedCtxt);
      this.savedCtxt = ctxt.clone();
      ctxt.curFrame.stack = args.concat(ctxt.curFrame.stack);
      if (debugFunc) {
        console.log();
        debugFunc.call(ctxt, '<callback>');
      }
      return ctxt._run();
    };

    Context.prototype.funcCall = function(debugFunc, segments) {
      this.frames.push(this.curFrame);
      this.curFrame = new Frame(segments);
      if (debugFunc) {
        debugFunc.call(this, '(');
      }
      return this._run();
    };

    Context.prototype._run = function(args) {
      var _ref;
      return (_ref = this.curFrame.codeFuncSegs[this.curFrame.segIdx++]) != null ? _ref.call(this) : void 0;
    };

    Context.prototype.wait = function() {
      if (this.callbacksPending < 1) {
        return this._run();
      }
    };

    Context.prototype.funcReturn = function() {
      var stack;
      stack = this.curFrame.stack;
      if ((this.curFrame = this.frames.pop())) {
        return this.curFrame.stack = stack.concat(this.curFrame.args, this.curFrame.stack);
      }
    };

    return Context;

  })();

  window.Context = new Context;

  compileFunc = function(funcSrc, pfx) {
    var dpth, exists, front, getFuncString, getString, idx, localVar, localVarIndexes, localVarsArr, ltn, m, matches, out, outFunc, parseWords, rest, restEsc, sym, topIdx, varSet, w, word, wordIdx, wordRegEx, wordsInLine, wrd, _, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4;
    getString = function(word, regex) {
      var chr0, chr1, delim, out, _ref;
      delim = word[0];
      out = delim;
      i = regex.lastIndex;
      while (i < funcSrc.length) {
        chr0 = funcSrc[i];
        chr1 = (_ref = funcSrc[i + 1]) != null ? _ref : ' ';
        if (chr0 === '\\') {
          out += chr0 + chr1;
          i += 2;
          continue;
        }
        out += chr0;
        if (chr0 === delim && /\s/.test(chr1)) {
          regex.lastIndex = i + 1;
          return out;
        }
        i++;
      }
      throw new Exception('Unterminated string');
    };
    getFuncString = function(word, regex) {
      var chr0, chr1, chr2, chr3, gs, out, wsIdx, _ref, _ref1, _ref2;
      out = word;
      i = regex.lastIndex;
      while (i < funcSrc.length) {
        chr0 = funcSrc[i];
        chr1 = (_ref = funcSrc[i + 1]) != null ? _ref : ' ';
        chr2 = (_ref1 = funcSrc[i + 2]) != null ? _ref1 : ' ';
        chr3 = (_ref2 = funcSrc[i + 3]) != null ? _ref2 : ' ';
        if (chr0 === '\\') {
          out += chr0 + chr1;
          i += 2;
          continue;
        }
        if (/\s/.test(chr0)) {
          if (chr1 === '/' && chr2 === '/') {
            while (++i < funcSrc.length && funcSrc[i] !== '\n') {}
            continue;
          } else if (chr1 === '"' || chr1 === "'" || chr1 === "`") {
            regex.lastIndex = i + 2;
            out += chr0 + (gs = getString(chr1, regex));
            i = regex.lastIndex;
            continue;
          } else if (chr1 === '(' && /\s/.test(chr2)) {
            regex.lastIndex = i + 2;
            out += chr0 + getFuncString('(', regex);
            i = regex.lastIndex;
            continue;
          } else if (chr1 === ':' && chr2 === '(' && /\s/.test(chr3)) {
            regex.lastIndex = i + 3;
            out += chr0 + getFuncString(':(', regex);
            i = regex.lastIndex;
            continue;
          } else if (chr1 === ')') {
            wsIdx = i;
            while (++wsIdx < funcSrc.length && /\S/.test(funcSrc[wsIdx])) {}
            regex.lastIndex = wsIdx;
            return out + funcSrc.slice(i, wsIdx);
          }
        }
        out += chr0;
        i++;
      }
      throw new Exception('Unmatched left paren');
    };
    parseWords = function(wordRegEx) {
      var comment, eolRegex, lastIndex, matches, whiteSpace, wordMatch, wordsInLine, _, _ref;
      wordsInLine = [];
      matches = true;
      lastIndex = wordRegEx.lastIndex;
      while (wordsInLine.length === 0 && matches) {
        while ((matches = wordRegEx.exec(funcSrc))) {
          _ = matches[0], wordMatch = matches[1], whiteSpace = matches[2];
          if ((comment = wordMatch.slice(0, 2) === '//')) {
            eolRegex = /\n|$/g;
            eolRegex.lastIndex = wordRegEx.lastIndex;
            eolRegex.exec(funcSrc);
            wordRegEx.lastIndex = eolRegex.lastIndex;
          } else {
            if ((_ref = wordMatch[0]) === '"' || _ref === "'" || _ref === "`") {
              wordRegEx.lastIndex = wordRegEx.lastIndex - wordMatch.length - whiteSpace.length + 1;
              wordMatch = getString(wordMatch, wordRegEx);
              whiteSpace = funcSrc[wordRegEx.lastIndex];
            } else if (/^:?\($/.test(wordMatch)) {
              wordRegEx.lastIndex = wordRegEx.lastIndex - whiteSpace.length;
              wordMatch = getFuncString(wordMatch, wordRegEx);
              whiteSpace = funcSrc[wordRegEx.lastIndex];
            }
            wordsInLine.unshift(wordMatch);
          }
          lastIndex = wordRegEx.lastIndex;
          if (comment || !whiteSpace || /\n/.test(whiteSpace)) {
            break;
          }
        }
        wordRegEx.lastIndex = lastIndex;
      }
      return wordsInLine;
    };
    out = function(word, line, dbgOk) {
      var dbgStr, str, _j;
      if (dbgOk == null) {
        dbgOk = true;
      }
      str = '';
      for (i = _j = 0; 0 <= depth ? _j < depth : _j > depth; i = 0 <= depth ? ++_j : --_j) {
        str += '  ';
      }
      str += line;
      if (word) {
        while (str.length < 75) {
          str += ' ';
        }
        dbgStr = '';
        if (debugRuntime && dbgOk) {
          dbgStr = longPad + 'fjsInspect.call(this, "' + word.replace(/"/g, "'") + '");';
        }
        return funcOut += str + ' /* ' + word + ' */' + dbgStr + '\n';
      } else {
        return funcOut += str + '\n';
      }
    };
    outFunc = function(src, exec) {
      var m, n;
      if (exec == null) {
        exec = true;
      }
      n = '';
      if ((m = /\)<(\d+)$/.exec(src))) {
        n = '0, ' + m[1];
      }
      if (exec) {
        if (n) {
          out(null, 'var fjs_argsArr = this.curFrame.stack.splice(' + n + ');');
        } else {
          out(null, 'var fjs_argsArr = this.curFrame.stack;');
          out(null, 'this.curFrame.stack = [];');
        }
        out(null, 'this.pushReturnValue( (function(){');
      } else {
        out(null, 'this.push( function(){');
      }
      depth++;
      out('(', 'this.setArgs(arguments);');
      if ((m = /^:?\((.*)\)<?(\d+)?$/.exec(src))) {
        src = m[1];
      }
      compileFunc(src, 'this');
      depth--;
      if (exec) {
        return out('()', '} ).apply( this, fjs_argsArr ));');
      } else {
        return out(null, '} );');
      }
    };
    if (debugRuntime && !haveDbgInspect) {
      out(null, "function fjsInspVal(fjs_stkDmp,fjs_item) {\n" + "   fjs_stkDmp.push(\n" + "     fjs_item === null ? 'null' : \n" + "     typeof fjs_item == 'string'  ? '\"'+fjs_item.replace(/\\s/g,' ')+'\"'          : \n" + "     typeof fjs_item == 'number'  ?  fjs_item                   : \n" + "     fjs_item instanceof Function ? 'function'                  : \n" + "     fjs_item instanceof Array    ? '['+fjs_item.toString()+']' : \n" + "     fjs_item instanceof Boolean  ? fjs_item.toString()         : \n" + "     (fjs_m = /^function\\s(.*?)\\(\\s/.exec(fjs_item.constructor)) ? fjs_m[1] :\n" + "     fjs_item.toString()\n" + "   );\n" + "}\n" + out(null, "function fjsInspect(fjs_word) {\n" + "  fjs_word = fjs_word.replace(/\\s/g,' ');" + "  while(fjs_word.length < 25) fjs_word += ' ';\n" + "  fjs_stkDmp = []; fjs_argDmp = []; fjs_frame = this.curFrame;\n" + "  if(fjs_frame) {\n" + "    fjs_stk = fjs_frame.stack; fjs_stkLen = fjs_stk.length;\n" + "    for(fjs_i=0; fjs_i<fjs_stkLen; fjs_i++)\n" + "      fjsInspVal(fjs_stkDmp,fjs_stk[fjs_i]);\n" + "    fjs_arg = fjs_frame.args; fjs_argLen = fjs_arg.length;\n" + "    for(fjs_i=0; fjs_i<fjs_argLen; fjs_i++)\n" + "      fjsInspVal(fjs_argDmp,fjs_arg[fjs_i]);\n" + "  }\n" + "  console.log( 'dbg: ' + fjs_word, '[ '+fjs_stkDmp.join(', ')+' ] /',\n" + "               '( '+fjs_argDmp.join(', ')+' )')\n" + "}\n"));
      haveDbgInspect = true;
    }
    localVarIndexes = {};
    wordRegEx = new RegExp('(\\S+)(\\s*)', 'g');
    wordIdx = -1;
    while ((wordsInLine = parseWords(wordRegEx)).length) {
      for (_j = 0, _len = wordsInLine.length; _j < _len; _j++) {
        word = wordsInLine[_j];
        wordIdx++;
        if ((word !== '=' && word !== '>=' && word !== '<=' && word !== 'not=') && word.slice(-1) === '=' && !/\./.test(word)) {
          word = word.slice(0, -1);
          exists = false;
          if (callDepth >= 0) {
            _ref = localVarStack.slice(0, +callDepth + 1 || 9e9);
            for (dpth = _k = 0, _len1 = _ref.length; _k < _len1; dpth = ++_k) {
              varSet = _ref[dpth];
              for (wrd in varSet) {
                idx = varSet[wrd];
                if (idx < localVarIdxStk[dpth]) {
                  if (wrd === word) {
                    exists = true;
                    break;
                  }
                }
              }
            }
          }
          if (!exists && !localVarIndexes[word]) {
            localVarIndexes[word] = wordIdx;
          }
        }
      }
    }
    withStmntStack.push([]);
    localVarStack.push(localVarIndexes);
    localVarIdxStk.push(-1);
    callDepth++;
    localVarsArr = [];
    for (localVar in localVarIndexes) {
      localVarsArr.push(encodeSymbol(localVar));
    }
    if (localVarsArr.length) {
      out(null, 'var ' + localVarsArr.join(', ') + ';');
    }
    out(null, pfx + '.funcCall( ' + (debugRuntime ? 'fjsInspect,' : 'null,'), false);
    depth++;
    out(null, '[');
    depth++;
    out(null, 'function() {');
    depth++;
    wordRegEx = new RegExp('(\\S+)(\\s*)', 'g');
    while ((wordsInLine = parseWords(wordRegEx)).length) {
      for (_l = 0, _len2 = wordsInLine.length; _l < _len2; _l++) {
        word = wordsInLine[_l];
        localVarIdxStk[callDepth]++;
        if (debugCompile) {
          console.log('- word:', localVarIdxStk[callDepth], word.slice(0, 61));
        }
        if ((_ref1 = word[0]) === '"' || _ref1 === "'") {
          out(word, 'this.push( ' + word + ' );');
        } else if (word[0] === "`") {
          out(word, 'this.push( ' + word.slice(1, -1) + ' );');
        } else if ((m = /^(:)?\(\s/.exec(word))) {
          outFunc(word, !m[1]);
        } else if (word.slice(0, 5) === 'with:') {
          topIdx = withStmntStack.length - 1;
          sym = encodeSymbol(word.slice(5));
          withStmntStack[topIdx].push(sym);
          out(null, 'with( ' + sym + ' ) {');
          depth++;
        } else if (word.slice(0, 7) === 'typeof:') {
          sym = encodeSymbol(word.slice(7));
          out(word, 'this.push( typeof ' + sym + ' );');
          depth++;
        } else if (word.slice(0, 11) === 'instanceof:') {
          sym = encodeSymbol(word.slice(11));
          out(word, 'this.push( this.pop() instanceof ' + sym + ' );');
          depth++;
        } else if (word === 'cb') {
          out(word, 'this.pushCB(' + (debugRuntime ? 'fjsInspect' : 'null') + ');');
        } else if (word === 'wait') {
          out(word, 'this.wait();');
          _ref2 = withStmntStack[withStmntStack.length - 1];
          for (_m = 0, _len3 = _ref2.length; _m < _len3; _m++) {
            i = _ref2[_m];
            depth--;
            out(null, '}');
          }
          depth--;
          out(null, '}, function() {');
          depth++;
          _ref3 = withStmntStack[withStmntStack.length - 1];
          for (_n = 0, _len4 = _ref3.length; _n < _len4; _n++) {
            w = _ref3[_n];
            out(null, 'with( ' + encodeSymbol(w) + ' ) {');
            depth++;
          }
        } else if (word[0] === ':') {
          rest = word.slice(1);
          restEsc = rest.replace(/"/g, '\\"');
          out(word, 'this.push( typeof ' + rest + ' == "function" ? ' + rest + ' : "' + restEsc + '" );');
        } else if (word.length > 1 && word.slice(-1) === '=') {
          out(word, (sym = encodeSymbol(word.slice(0, -1))) + ' = this.pop();');
        } else if ((matches = /^@(@|(\d*))$/.exec(word))) {
          ltn = (function() {
            switch (false) {
              case !!matches[1]:
                return 1;
              case !matches[2]:
                return matches[2];
              default:
                return '';
            }
          })();
          out(word, 'this.moveArgsToStack(' + ltn + ');');
        } else if ((m = /^(\S+)<(\d*)$/.exec(word))) {
          _ = m[0], front = m[1], ltn = m[2];
          ltn || (ltn = 'null');
          out(word, 'this.pushArgsAndExec( ' + encodeSymbol(front) + ', ' + ltn + ' );');
        } else if ((m = /^(\S+)\.$/.exec(word))) {
          if (!(front = m[1])) {
            out('.', 'this.execOrPush( _dot_ );');
          } else {
            sym = encodeSymbol(front);
            out(null, 'fjs_ctxtObj = this.pop();');
            out(null, 'fjs_val = fjs_ctxtObj.' + sym + ';');
            out(null, 'if(typeof fjs_val == "function")');
            out(null, '  fjs_val = fjs_val.apply(');
            out(null, '      fjs_ctxtObj, this.curFrame.stack );');
            out(null, '  this.curFrame.stack = [];');
            out(word, 'this.pushReturnValue(fjs_val);');
          }
        } else {
          out(word, 'this.execOrPush( ' + encodeSymbol(word) + ' );');
        }
      }
    }
    out(')', 'this.funcReturn();');
    _ref4 = withStmntStack[withStmntStack.length - 1];
    for (_o = 0, _len5 = _ref4.length; _o < _len5; _o++) {
      i = _ref4[_o];
      depth--;
      out(null, '}');
    }
    depth--;
    out(null, '}');
    depth--;
    out(null, ']');
    withStmntStack.pop();
    localVarStack.pop();
    localVarIdxStk.pop();
    callDepth--;
    depth--;
    out(null, ');');
    if (debugCompile) {
      return console.log('- word: ' + (localVarIdxStk[callDepth] + 1) + ' )');
    }
  };

  nameByChar = {
    '!': 'bang',
    '"': 'quot',
    '#': 'hash',
    '%': 'pcent',
    '&': 'amp',
    "'": 'tick',
    '(': 'lparen',
    ')': 'rparen',
    '*': 'star',
    '+': 'plus',
    ',': 'comma',
    '-': 'dash',
    '/': 'slash',
    ':': 'colon',
    ';': 'semi',
    '<': 'lt',
    '=': 'eq',
    '>': 'gt',
    '?': 'qmark',
    '@': 'at',
    '[': 'lbkt',
    '\\': 'bslsh',
    ']': 'rbkt',
    '^': 'caret',
    '`': 'btick',
    '{': 'lbrace',
    '|': 'pipe',
    '}': 'rbrace',
    '~': 'tilda'
  };

  charByName = {
    'bang': '!',
    'quot': '"',
    'hash': '#',
    'pcent': '%',
    'amp': '&',
    'tick': "'",
    'lparen': '(',
    'rparen': ')',
    'star': '*',
    'plus': '+',
    'comma': ',',
    'dash': '-',
    'slash': '/',
    'colon': ':',
    'semi': ';',
    'lt': '<',
    'eq': '=',
    'gt': '>',
    'qmark': '?',
    'at': '@',
    'lbkt': '[',
    'bslsh': '\\',
    'rbkt': ']',
    'caret': '^',
    'btick': '`',
    'lbrace': '{',
    'pipe': '|',
    'rbrace': '}',
    'tilda': '~'
  };

  symByWord = {
    "throw": '_throw_',
    "if": '_if_',
    "while": '_while_',
    '.': '_dot_',
    "new": '_new_'
  };

  wordBySym = {
    _throw_: 'throw',
    _if_: 'if',
    _while_: 'while',
    _dot_: '.',
    _new_: 'new'
  };

  encodeSymbol = function(str) {
    var char, name, out, _j, _len;
    if (str.length === 0) {
      return str;
    }
    if (str[0] === '`') {
      return str.slice(1);
    }
    if (str in symByWord) {
      return symByWord[str];
    }
    out = '';
    for (_j = 0, _len = str.length; _j < _len; _j++) {
      char = str[_j];
      if ((name = nameByChar[char])) {
        out += '_' + name + '_';
      } else {
        out += char;
      }
    }
    if (isNaN(out) && /^\d/.test(out)) {
      out = '_num_' + out;
    }
    return out;
  };

  decodeSymbol = function(str) {
    var char, name, regex;
    if (str in wordBySym) {
      return wordBySym[str];
    }
    for (name in charByName) {
      char = charByName[name];
      regex = new Regexp('_' + name + '_', 'g');
      str = str.replace(regex, char);
    }
    return str;
  };

  if (window.FJS == null) {
    window.FJS = {};
  }

  window.FJS.compile = function(src) {
    resetFuncOut();
    compileFunc("with:Primitives\n\n" + src, "Context");
    return funcOut;
  };

  window.FJS.execute = function(src) {
    return window["eval"](this.compile(src));
  };

}).call(this);
